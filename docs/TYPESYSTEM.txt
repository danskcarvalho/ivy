data ArraySpecification = OneElement | ManyElements(uint) | Flexible
data(flags) StructFlags = Packed | DefaultInit

data StructField = {
                       Name      :: String
                       Type      :: ConstShared<ProperType>
                       Alignment :: uint?
                       Array     :: ArraySpecification
                   }

data ClassMember = Function(Name :: [char], ProperType.ConstShared)

data TypeId = TypeId(Symbol*, [TypeId])

data ProperType   = Primitive(TypeId, Size :: uint, Alignment :: uint)
                    Struct   (TypeId, [StructField], StructFlags)
                    Union    (TypeId, [StructField], UnionFlags)
                    Enum     (TypeId, [NamedConstructor], EnumFlags)
data ClassType    = Class    (TypeId, [ClassMember], ClassFlags)
data InstanceType = Instance (TypeId, ClassType.ConstShared)

let Int8Type  = Proper(Primitive(Int8,  1, 1))
let Int16Type = Proper(Primitive(Int16, 2, 2))

data Type = Proper(ProperType.ConstShared) | Class(ClassType.ConstShared) | Instance(InstanceType.ConstShared)

def Kind(let& T :: ConstShared<Type>) -> Kind

class TypeConstructor<C>:
    extension C:
        let ParameterCount -> uint
        let ParameterKind(uint) -> let Kind&
        let ReturnKind() -> let Kind&
        let Construct([Type]) -> Type
        let TypeConstructorKind() -> Kind

data KindParameter = Independent(Id :: uint, Kind) | Dependent(uint)

data Kind = Type
            Class
            TypeConstructor ([KindParameter])
            ClassConstructor([KindParameter])
            Constructed<C, C.TypeConstructor>(C.ConstShared, [KindParameter])

//<A :: *, Equatable<A, List<A>>> -> *
TypeConstructor([Independent(0, Type), Constructed(EquatableConstructor, [Dependent(0), Constructed(ListConstructor, [Dependent(0)])])])